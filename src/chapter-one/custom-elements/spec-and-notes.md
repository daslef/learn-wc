# Спецификация и общие рекомендации

## Спецификация пользовательских компонентов

Чтобы создать пользовательский элемент, нам нужно сообщить браузеру ряд деталей о нём: как его показать, что делать, когда элемент добавляется или удаляется со страницы и т.д.

```js
{
  constructor() {
    super();
    // элемент создан
    // можно выполнить предварительную настройку, но рендерить еще рано
  }

  connectedCallback() {
    // браузер вызывает этот метод при добавлении элемента в документ
    // может вызываться много раз, если элемент многократно добавляется/удаляется
    // здесь мы обычно задаем содержимое элемента (разметку) и рендерим его
  }

  disconnectedCallback() {
    // браузер вызывает этот метод при удалении элемента из документа
    // может вызываться много раз, если элемент многократно добавляется/удаляется
  }

  static get observedAttributes() {
    return [/* массив имён атрибутов для отслеживания их изменений */];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // вызывается при изменении одного из перечисленных выше атрибутов
  }

  adoptedCallback() {
    // вызывается, когда элемент перемещается в новый документ
    // используется очень редко
  }

  // специфичные для элемента свойства и методы

  // пользовательские вспомогательные свойства и методы
}
```

Видим, что методов не много, и все они являются необязательными.

Итак, мы создаем класс с необходимыми нам методами, наследуясь от класса `HTMLElement` в случае автономных пользовательских элементов либо от более специфичного класса в случае со встроенными пользовательскими элементами. Далее - реализуем собственные вспомогательные функции, если нужно - стилизуем.

После этого регистрируем элемент через предназначенный для этого метод `customElements.define`, задавая ему название. Важно, что название должно содержать дефис, во избежание коллизий с нативными элементами. Так, *ui-div* будет корректным именованием, а *uidiv* и *div* - нет.

Готово - теперь можем использовать элемент как через HTML (просто добавить в документ, как любой нативный тег), так и через JS (createElement).

Важно понимать порядок рендеринга: когда HTML-парсер строит DOM, элементы обрабатываются друг за другом, родители до детей. Например, если у нас есть `<outer><inner></inner></outer>`, то элемент `<outer>` создаётся и включается в DOM первым, а затем `<inner>`. Это приводит к важным последствиям для пользовательских элементов: так, если пользовательский элемент пытается получить доступ к *innerHTML* в *connectedCallback*, он ничего не получает. Это происходит именно потому, что на этой стадии ещё не существуют дочерние элементы, DOM не завершён. HTML-парсер подключил пользовательский элемент `<user-info>` и теперь собирается перейти к его дочерним элементам, но пока не сделал этого. Если мы хотим передать информацию в пользовательский элемент, мы можем использовать атрибуты (они доступны сразу), отложить доступ к ним через setTimeout с нулевой задержкой (костыль, но работает), либо реализовать свой механизм общения между родителями и детьми через механизм `Custom Events`.

## Примечания

#### О регистрации пользовательских элементов

`customElements.define` выдаст ошибку, если тег уже был определен. При использовании ES-модулей и механизма импорта эта проблема обязательно возникнет.

```js
Failed to execute 'define' on 'CustomElementRegistry': this name has already been used with this registry
```

Но это легко обработать. Метод `customElements.get('my-custom-tag')` возвращает логическое значение, говорящее, зарегистрирован ли элемент. Обернув в условную конструкцию, мы можем вызывать регистрацию только тогда, если она еще не выполнена.

```js
if (!customElements.get('my-custom-tag')) {
    customElements.define('my-custom-tag', class extends HTMLElement {});
}
```

#### Определение пользовательских элементов

Если браузер сталкивается с пользовательскими элементами до `customElements.define`, то это не ошибка. Но элемент пока неизвестен, как и любой нестандартный тег. Такие «неопределённые» элементы могут быть стилизованы с помощью CSS селектора `:not(:defined)`.

Когда вызывается `customElements.define`, они «обновляются»: для каждого создаётся новый экземпляр и вызывается `connectedCallback`. Они становятся `:defined`.

Чтобы получить информацию о пользовательских элементах, есть следующие методы:
- `customElements.get(name)` – возвращает класс пользовательского элемента с указанным именем name,
- `customElements.whenDefined(name)` – возвращает промис, который переходит в состояние «успешно выполнен» со значением конструктора пользовательского элемента, когда определён пользовательский элемент с указанным именем name.

#### Рендеринг

Рендеринг происходит в `connectedCallback`, не в `constructor` Причина проста: когда вызывается `constructor`, делать это слишком рано. Экземпляр элемента создан, но на этом этапе браузер ещё не обработал/назначил атрибуты: вызовы `getAttribute` вернули бы `null`, поэтому мы не можем рендерить здесь. Кроме того, если подумать, это лучше с точки зрения производительности – отложить работу до тех пор, пока она действительно не понадобится.

`connectedCallback` срабатывает, когда элемент добавляется в документ. Не просто добавляется к другому элементу как дочерний, но фактически становится частью страницы. Таким образом, мы можем построить отдельный DOM, создать элементы и подготовить их для последующего использования. Они будут рендериться только тогда, когда попадут на страницу.


## Поддержка браузерами

[Полифилл](https://github.com/webcomponents/polyfills/tree/master/packages/custom-elements)
