# Обработка событий

Идеи, которые стоят за Веб Компонентами, предполагают более сложную работу с событиями, чем мы привыкли. В этом разделе предварительно освежим событийную модель JS, а потом поговорим о различных техниках работы с пользовательскими элементами и теневым деревом.

## Событийная модель JS

#### Обработчики событий

Каждый HTML-элемент содержит набор событий, ассоциированных с ним. При возникновении события, приложение исполняет набор относящихся к нему задач, описанных в *обработчиках событий*. Назначить обработчик можно либо через атрибут HTML-элемента, начинающийся с *on*, например, *onclick*, либо через метод *addEventListener*. Второй вариант рекомендован, так как позволяет назначить событию сразу несколько обработчиков. Если назначить элементу и событию несколько обработчиков, они будут исполняться в том порядке, в котором были назначены.

Удалить обработчик возможно только программно, через JS, методом `removeEventListener` с теми же параметрами, которые передавались при его установке.

Некоторые события формируют цепочки. Например событию `keypress` предшествуют `keydown` и `keyup`, а событие `click` следует за `mousedown` и `mouseup`.

Порой выбрать правильное событие для обработки сложнее, чем реализовать обработчик. Рекомендуется пользоваться [справочником MDN](https://developer.mozilla.org/en-US/docs/Web/Events)

#### Предотвращение поведения по умолчанию

Многие элементы запрограммированы реагировать на некоторые события "из коробки". Например, при щелчке по ссылке автоматически происходит переход в согласии с ее атрибутом *href*.

Если мы прикрепим к ссылке свой обработчик, он будет выполнен первым, но после него отработает и встроенная функциональность. Чтобы подавить поведение элемента по умолчанию, мы используем метод `preventDefault` в случае обработчиков, назначенных через `addEventListener`, либо через `return false` из обработчиков, назначенных через атрибут *on[event]*.

#### Всплытие событий

Чтобы понять, что такое всплытие, мы можем посмотреть на HTML-страницу как на стопку слоев. Каждый уровень DOM-дерева в документе формирует слой.

Допустим, у нас есть документ, содержащий элемент `<div>`. Тогда нижний слой - это `body`, а верхний слой - это `div`. Если пользователь кликает внутри элемента `div`, то именно этот элемент получает событий первым. Если к нему привязаны обработчики, они выполняются. Иначе событие передается на следующий слой - в нашем случае на тело документа. В браузере всплытие происходит даже дальше: от тела документа `<body>` к корню документа `html`, а далее - к элементу `Window`. Это и есть всплытие события, которое происходит до тех пор, пока не остановится на каком-либо из элементов.

Передача событий называется *propagation*, и мы можем работать с ним программно. Получив объект `event` в обработчике события, его можно использовать для остановки всплытия.

```js
element.addEventListener("click", event => {
    event.stopPropagation();
});
```

Если на элементе закреплено несколько обработчиков одного и того же события, то даже если мы остановим всплытие в одном из обработчиков, остальные продолжат исполнение. Чтобы остановить всплытие и остановить исполнение остальных обработчиков, существует метод `event.stopImmediatePropagation`.

#### Event.target и Event.currentTarget

Объект события предоставляет множество информации. Например, при щелчке мышью мы можем узнать координаты клика и кнопку мыши. Но для работы со всплытием нам интересны его свойства `target` и `currentTarget`. Первое свойство отдает ссылку на элемент, на котором произошло событие, а второе - на элемент, на котором реализован обработчик этого события.

Если обработчик сработал на том элементе, на котором произошло событие, то эти два свойства будут ссылаться на один и тот же элемент. Но обработчик может быть назначен не конкретно на этот элемент, а на более высоких слоях. Например, карточка товара может содержать описание товара в элементе `<p>`: мы кликаем по элементу `<p>` с описанием товара, но обработчик клика назначен на карточке товара `<article>`, которая расположена выше в иерархии DOM-дерева. Тогда через `event.target` мы получим элемент с описанием, а через `event.currentTarget` - элемент, на котором назначен обработчик, то есть элемент с карточкой.

Если мы представим маркированный список, то вместо того, чтобы вешать обработчики на каждый из элементов `<li>` это позволяет нам назначить один обработчик на элемент `<ul>`. Если событие произойдет на `<li>`, он будет являться `event.target`, тогда как `event.currentTarget` отдаст нам `<ul>`.

Благодаря всплытию событий, существует подход, при котором некоторые обработчики устанавливаются прямо на документ. Тогда дополнительную информацию о событии мы получаем через `e.target` и выполняем действия ориентируясь на него.

Большая часть событий всплывают, но не все. Например, событие `focus` происходит на полях ввода и не всплывает, и либо мы обрабатываем его, либо оно отбрасывается.

#### Захват события

Захват события - альтернатива всплытию, направленная не от источника события к корню документа, а наоборот. Например, в случае с описанием товара это может быть следующий путь: Window -> Document -> HTML -> Body -> Article -> Target (p).

Чтобы переключиться на этот метод распространения события, нужно передать `true` в качестве третьего аргумента метода `addEventListener`.

#### Пассивные события

При движении пальцем на мобильных устройствах срабатывает событие `touchmove`, за которым по цепочке следует скроллинг. Обычно браузер сначала исполняет пользовательские обработчики, и лишь затем, если в них не вызывается `preventDefault`, исполняет встроенные обработчики. Это может приводит к задержкам в UI. Опция `{ passive: true }` сообщает браузеру, что пользовательский обработчик не будет его отменять, и тогда встроенная реализация отрабатывает до пользовательской, обеспечивая плавный пользовательский опыт.

## События в Веб Компонентах

```html
<user-card></user-card>
<script>
    customElements.define('user-card', class extends HTMLElement {
        connectedCallback() {
            this.attachShadow({mode: 'open'});
            this.shadowRoot.innerHTML = `<p><button>Click me</button></p>`;
            this.shadowRoot.firstElementChild.onclick = e => alert("Inner target: " + e.target.tagName);
        }
    });

    document.onclick =  e => alert("Outer target: " + e.target.tagName);
</script>
```

В этом примере обработчик прикреплен к Shadow DOM через его первого наследника. При клике будет выведено *Inner target: BUTTON* и *Outer target: USER-CARD*. Как и требует инкапсуляция, извне информация о внутренней реализации недоступна и ограничена границами теневого DOM, а внутри самого дерева - доступна. Это называется `event retargeting`, перенаправление событий.

Если событие происходит на элементе, размещенном в слоте, перенаправление события не происходит. Всё потому, что элементы, размещаемые в слотах, находятся в обычном DOM. Например, при щелчке на некоторый элемент `<span slot="username">` таргетом события по обе границы теневого DOM будет `span`.

Чтобы теневое дерево не ограничивало процессы всплытия событий, применяется *flattened DOM*. При описанном выше клике на элемент `<span slot="username">` событие всплывает на уровень элемента `<slot>`, после чего через `#shadow-root` и пользовательский компонент последовательно всплывает к объекту `window`.

Тем не менее, есть несколько событий, которые не преодолевают границы теневого DOM при всплытии. Это поведение определяется свойством событий *composed*: при *true* оно преодолевает границы, при *false* нет. События *load*, *unload*, *select*, *slotchange* не преодолевают границы теневого DOM и могут быть обработаны только внутри него, а события `mouseenter` и `mouseleave` настроены так, что даже не всплывают.

## Пользовательские события

Пользовательские (синтетические) события позволяют определять и генерировать свои события: `new CustomEvent('test', { detail: 'additional info' })`

Если мы хотим, чтобы такие события всплывали за пределы теневого DOM, важно выставить им при создании свойства `{ bubbles: true, composed: true }`.

Для генерации события на элементе используется `dispatchEvent API`: `someElement.dispatchEvent(new CustomEvent('test', { detail: 'additional info', bubbles: true, composed: true }))`

```html
<section class="entry"></section>
<script>
    const sectionElement = document.querySelector('.entry')
    const shadowRoot = sectionElement.attachShadow({ mode: 'open' });
    shadowRoot.innerHTML = '<label id="name"><input for="name" /></label><button>Fire!</button>';

    const [labelElement, buttonElement] = shadowRoot.childNodes

    labelElement.addEventListener('test', event => alert('shadow: ' + event.detail));
    document.addEventListener('test', event => alert('light: ' + event.detail));

    buttonElement.addEventListener('click', () => {
        labelElement.dispatchEvent(new CustomEvent('test', { bubbles: true, composed: true, detail: "composed" }));
        labelElement.dispatchEvent(new CustomEvent('test', { bubbles: true, composed: false, detail: "not composed" }));
    })
</script>
```

<iframe src="/events/events-example-1.html" />

Здесь два пользовательских события вызываются на внутреннем элементе, и снаружи теневого дерева доступно только то, которому выставлен `{ composed: true }`.

Третье свойство, доступное при создании пользовательского события, это `cancelable`, определяющий, может ли событие быть отменено через `preventDefault` (по умолчанию - нет).

