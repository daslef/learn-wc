# Микро-библиотека `easy-wc`

## Функция `attachTemplate`

Итак, `attachStyle` это универсальная функция, подходящая и для *встроенных пользовательских элементов*, и для *автономных пользовательских элементов*. А вот для задания шаблона у нас есть только `attachShadow`,а значит шаблоны без теневого дерева задавать мы пока не можем. Мы не заметили этого, т.к. элемент *ButtonComponent* опирался на встроенный шаблон и в нем задавались только стили, но так будет не всегда.

Создадим файл `src/lib/easy-wc/template/template.ts` и функцию *attachTemplate*. Она будет принимать контекст - то есть элемент, которому мы назначаем разметку. Внутри создадим шаблон, наполним его содержимым и клонируем его содержимое в элемент.

```ts
// src/lib/easy-wc/template/template.ts

import type { ElementMeta } from "../decorator";

type DecoratedElement = HTMLElement & { elementMeta: ElementMeta }

export function attachTemplate(context: DecoratedElement): void {
  const template = document.createElement("template");
  template.innerHTML = context.elementMeta.template ?? "";
  context.appendChild(template.content.cloneNode(true));
}
```

В таком виде мы сможем прикреплять шаблон к элементам без теневого дерева, а для них - продолжим использовать функцию *attachShadow*.

Пока этого достаточно. Добавьте необходимые экспорты.

## Тэггированные шаблонные литералы

Поработаем над DX, удобством для разработчиков. Сейчас наши стили и разметка, передаваемые в декоратор в виде шаблонных строк, не определяются IDE как HTML и CSS, соответственно мы не получаем подсветки синтаксиса и подсказок об ошибках.

После установки расширения *es6-string-html* (для VS Code) мы заметим, что код в шаблонных строках в файлах со стори, начал подсвечиваться. Это потому, что там используем библиотеку *lit-html*, которая имеет некоторую особую функциональность. Особая функциональность - это использование тэггированных шаблонных литералов, которые появились в JS со спецификацией ES2015.

В наших файлах подсветки всё еще нет. Мы могли бы подцепить *lit-html* к нашей библиотеке, но это лишит ее преимущества в виде небольшого объема. Но также мы можем написать свой упрощенный аналог.

Создадим в `src/lib/easy-wc/template/template.ts` две новых функции, `css` и `html`. Их содержимое будет полностью идентичным, поэтому мы напишем одну функцию, но экспортируем под двумя именами.

Функция должна принимать на вход данные в особом формате `TemplateStringsArray` в качестве первого аргумента. Это массив простых строк, разбитых по разделителю `${}`. Второй аргумент - собственно те динамические участки, которые должны быть вычислены и встроены в шаблон. Их может быть неопределенное количество, поэтому мы собираем их оператором *...* в единый массив. Внутри функции мы объединяем их в единую строку и отдаем.

```ts
// src/lib/easy-wc/template/template.ts

// ...

function tagged(template: TemplateStringsArray, ...rest: any): string {
    let str = "";

    template.forEach((string, i) => {
        str += `${string} ${rest[i] || ""}`;
    });

    return str;
}

export { tagged as html, tagged as css }
```
