# Микро-библиотека `easy-wc`

## Декоратор класса

Реализация декоратора класса позволит освободить конструктор от сопроводительного кода, выделив оттуда HTML-шаблон и стили.

Например, `ButtonComponent` будет выглядеть следующим образом (но и это не предел).

```ts
@Component({
    custom: { extends: "button" },
    selector: "in-button",
    style: buttonStyles,
})
export class ButtonComponent extends HTMLButtonElement {
    constructor() {
        super();
    }
    connectedCallback() {
        this.classList.add("in-button");
        attachStyle(this);
    }
}
```

Мы будем вести работу в директории `src/lib/easy-wc`. Создадим в ней точку входа, `index.ts`, откуда будут экспортироваться ключевые декораторы и функции. Также, создадим внутри нее директорию `decorator` с файлами `index.ts` и `component.ts`.

## Определение интерфейса

Начнем с определения интерфейса будущего декоратора

```ts
// src/lib/easy-wc/decorator/component.ts

export interface ElementMeta {
    selector?: string;
    style?: string;
    template?: string;
}
```

Все три свойства являются опциональными для максимальной гибкости для пользователя библиотеки. При этом наша задача обработать эти ситуации в декораторе, предоставив безопасные умолчания.

## @Component

Декораторы в `TypeScript` - это фабричные функции. Они возвращают функцию, создающую объект. Объект, который интересует нас в случае декорирования классов, это его прототип.

Опираясь на значения из `ElementMeta`, мы будем модифицировать прототип класса таким образом, чтобы встроить туда регистрацию компонента и инициализацию HTML-шаблона внутри теневого DOM.

Создайте (и экспортируйте) функцию *Component* с входным параметром *meta*, возвращающую функцию. Она будет принимать на вход декорируемый класс под именем *target* и возвращать его модифицированную версию.

Начнем с регистрации элемента. При этом дадим пользователю возможность не задавать селектор, так как некоторые предпочитают регистрировать элементы не при определении, а по требованию.

```ts
// src/lib/easy-wc/decorator/component.ts

// ...
export function Component(meta: ElementMeta) {
    return (target: any) => {
        if (meta.selector) {
            customElements.define(meta.selector, target)
        }

        return target;
    };
}
```

Пока мы добавили вспомогательный вызов, но основное назначение классовых декораторов - это модификация прототипа декорируемого класса.

К сожалению, мы не можем создать теневое дерево прямо внутри декоратора,так как в нем есть доступ только к определению класса, но не к его экземпляру. Поэтому мы можем лишь заложить дополнительную информацию в прототип класса "на будущее". Далее, уже в конструкторе, мы ее используем.

Заодно добавим пост-обработку потенциально не заданных свойств стиля и шаблона.

```ts
// src/lib/easy-wc/decorator/component.ts

// ...
export function Component(meta: ElementMeta) {
    return (target: any) => {
        target.prototype.elementMeta = {
            style: meta.style ?? "",
            template: meta.template ?? ""
        };

        if (meta.selector) {
            customElements.define(meta.selector, target)
        }

        return target;
    };
}
```

Добавим экспорты для функции *Component* и для интерфейса *ElementMeta* в индекс-файлы и попробуем импортировать их в компонент *CardComponent*.
