# Микро-библиотека `easy-wc`

Мы выполнили уже три проекта на основе спецификаций Веб Компонентов, без использования каких-либо фреймворков. Это дает нам независимость, но мы теряем абстракции, которые могли бы дать нам фреймворки и делают разработку более императивной: например, хуки *React*, сигналы *Solid*, руны *Svelte*, стейт-менеджмент и так далее.

Существует немало библиотек, построенных специально для Веб Компонентов, и чуть позже мы поработаем с ними. А пока - разработаем собственную небольшую (менее 1 КБ) библиотеку.

Она позволит превратить такой код...

```ts
class MyComponent extends HTMLElement {
    constructor() {
        super();
        const shadowRoot = this.attachShadow({ mode: "open" });
        const template = document.createElement("template");
        template.innerHTML = `
            <style>
                :host {
                    display: block;
                    width: 100%;
                    font-family: var(--font-default);
                    font-size: var(--font-body-sm);
                }
            </style>
            <div class="container"></div>
        `;
        shadowRoot.appendChild(template.content.cloneNode(true));
    }
}

customElements.register("my-component", MyComponent);
```

... в более компактный и структурированный

```ts
@Component({
    selector: "my-component",
    style: css`
        :host {
            display: block;
            width: 100%;
            font-family: var(--font-default);
            font-size: var(--font-body-sm);
        }
    `,
    template: html` <div class="container"></div>`,
})
class MyComponent extends HTMLElement {
    constructor() {
        super();
        attachShadow(this, { mode: "open" });
    }
}
```

Иными словами, мы разработаем декоратор *@Component*, принимающий в качестве аргумента объект с настройками имени элемента, стилей и шаблона. Этот декоратор будет оборачивать класс с компонентом и прятать ряд шагов, повторяющихся во всех Веб Компонентах (определите эти шаги самостоятельно), оставляя место для специфичных настроек.

Паттерн *декоратор* работает через *TypeScript*, за это отвечает настройка `"experimentalDecorators": true` в `tsconfig.json`. При сборке и компиляции в JS декоратор будет заменен на соответствующий JS-код.

Помимо декаратора класса, мы также разработаем декоратор метода для прослушивания событий.

## О проекте

В этом проекте мы разработаем микро-библиотеку для абстрагирования типовой логики построения Веб Компонентов. По завершению можно будет произвести рефакторинг реализованных ранее компонентов `ButtonComponent` и `CardComponent` с ее использованием.

## Что мы изучим

- типовые задачи, встречающиеся при разработке пользовательских элементов,
- паттерн Декоратор,
- способы добавления шаблонов в теневой DOM,
- способы обработки стилей,
- способы добавления шаблонов к элементам, не поддерживающим теневой DOM,

## Требования к приемке

- экспортирован декоратор *Component*
- экспортированы функции *html*, *css*, *attachShadow*, *attachStyle* и *attachTemplate*,
- компоненты *ButtonComponent* и *CardComponent* отрефакторены с использованием библиотеки,
- все тесты проходят.
